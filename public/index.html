<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNEW</title>
    <style>
        :root {
            --paddle-color: #f14552;
            --ball-color: #0ce9f7;
        }
        
        body {
            background: #000;
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }
        
        canvas {
            border: 2px solid white;
            display: block;
            margin: 0 auto;
            background: #000;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            margin: 0 auto;
        }
        
        #game-info {
            text-align: center;
            font-size: 20px;
            margin-top: 10px;
            color: white;
        }
        
        #replay-button {
            display: none;
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 18px;
            background: #f14552;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid var(--paddle-color);
        }
        
        #menu h1 {
            color: var(--paddle-color);
            margin-bottom: 20px;
        }
        
        #menu button {
            background: var(--paddle-color);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #menu button:hover {
            background: var(--ball-color);
        }
        
        #portal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,0,0.5) 0%, rgba(10,144,10,0.3) 70%, transparent 100%);
            transition: width 0.1s, height 0.1s;
            pointer-events: none;
        }
        
        #portal.active {
            box-shadow: 0 0 20px #0f0;
        }
        
        #portal-button {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            font-size: 16px;
            background: #1cb31c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 5;
        }
        
        #portal-button:hover {
            background: #0a900a;
            box-shadow: 0 0 10px rgba(28, 179, 28, 0.7);
        }

        .portal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-radius: 50%;
            background: linear-gradient(to right, #0a900a, #1cb31c);
            opacity: 0;
            box-shadow: 0 0 30px #1cb31c;
            z-index: 4;
            transition: all 0.2s ease-out;
        }

        .portal.active {
            width: 100px;
            height: 100px;
            opacity: 0.8;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 10px 5px rgba(28, 179, 28, 0.8);
            }
            50% {
                box-shadow: 0 0 20px 10px rgba(28, 179, 28, 0.8);
            }
            100% {
                box-shadow: 0 0 10px 5px rgba(28, 179, 28, 0.8);
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="game-info"></div>
        <button id="replay-button">Play Again</button>
        <button id="portal-button">Open Portal</button>
        <button id="toggle-audio">üîä</button>
        
        <div id="menu">
            <h1>SNEW</h1>
            <button id="start-button">Start Game</button>
            <div id="controls-container">
                <h2>Controls</h2>
                <div class="control-group">
                    <p>Select Paddle: <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span></p>
                    <p>Move Paddle: <span class="key">‚Üë</span> <span class="key">‚Üì</span> <span class="key">‚Üê</span> <span class="key">‚Üí</span></p>
                    <p>Toggle Audio: <span class="key">M</span></p>
                </div>
                <div class="control-group">
                    <p>AI Enemies:</p>
                    <label class="switch">
                        <input type="checkbox" id="ai-enemies-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
        </div>
        
        <div id="portal"></div>
    </div>

    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è Vibe Jam 2025</a>

    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const gameInfo = document.getElementById('game-info');
        const startButton = document.getElementById('start-button');
        const replayButton = document.getElementById('replay-button');
        const toggleAudioButton = document.getElementById('toggle-audio');
        let API_KEY = ''; // For security, add your API key through environment variables when deploying
        
        // Safely check for environment variables
        try {
            if (typeof import.meta !== 'undefined' && import.meta.env && import.meta.env.VITE_API_KEY) {
                API_KEY = import.meta.env.VITE_API_KEY;
            } else if (window.ENV && window.ENV.VITE_API_KEY) {
                API_KEY = window.ENV.VITE_API_KEY;
            }
        } catch (e) {
            console.log('Environment variables not available, using default API key');
        }
        
        // Game constants
        const PADDLE_WIDTH = 125;
        const PADDLE_HEIGHT = 15;
        const BALL_SIZE = 10;
        const GNOME_SIZE = BALL_SIZE * 2;
        const GNOME_IMAGE_SIZE = GNOME_SIZE * 8;
        const INITIAL_BALL_SPEED = 1.5;
        const PADDLE_SPEED = 14;
        const GNOME_SPEED = 1;
        const MAX_LEVEL = 5;
        const INITIAL_HEARTS = 10;
        const PADDLE_COLOR = "#f14552";
        const BALL_COLOR = "#0ce9f7";

        // Portal related variables
        let portalActive = false;
        let portalSize = 0;
        const MAX_PORTAL_SIZE = 150;
        const PORTAL_GROWTH_RATE = 1;
        const SUCTION_FORCE = 0.5;

        // AI Enemy
        let aiEnemy = null;
        let aiEnemyEffect = null;
        let aiEnemiesEnabled = false;

        // Audio Context and buffers
        let audioContext;
        let gameplayBuffer = null;
        let victoryBuffer = null;
        let gameplaySource = null;
        let victorySource = null;
        let audioPlaying = true;

        // Load gnome image
        const gnomeImage = new Image();
        gnomeImage.src = "https://dl.dropboxusercontent.com/scl/fi/z9c83bdgiya3lv7ppjxgb/Gnome.png?rlkey=qzyw45wsrjb63f1tg2dpfxucl&st=7j1x91n8&raw=1";

        // Game state
        let gameState = {
            hearts: INITIAL_HEARTS,
            level: 1,
            score: 0,
            isGameOver: false,
            isVictory: false,
            ballSpeed: INITIAL_BALL_SPEED,
            ballCanKill: false,
            gameStarted: false
        };

        // Track if game loop has started
        let gameLoopStarted = false;

        // Paddles
        let paddles = {
            left: { x: 0, y: canvas.height / 2 - PADDLE_WIDTH / 2, width: PADDLE_HEIGHT, height: PADDLE_WIDTH, active: false },
            right: { x: canvas.width - PADDLE_HEIGHT, y: canvas.height / 2 - PADDLE_WIDTH / 2, width: PADDLE_HEIGHT, height: PADDLE_WIDTH, active: false },
            top: { x: canvas.width / 2 - PADDLE_WIDTH / 2, y: 0, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, active: false },
            bottom: { x: canvas.width / 2 - PADDLE_WIDTH / 2, y: canvas.height - PADDLE_HEIGHT, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, active: false }
        };

        // Ball and Gnomes initialization
        let ball = resetBall();
        let gnomes = [];

        // Event listeners
        startButton.addEventListener('click', startGame);
        replayButton.addEventListener('click', resetGame);
        toggleAudioButton.addEventListener('click', toggleAudio);
        document.getElementById('ai-enemies-toggle').addEventListener('change', function() {
            aiEnemiesEnabled = this.checked;
        });
        document.getElementById('portal-button').addEventListener('click', activatePortal);

        // Initialize audio 
        loadAudio();
        
        // Add event listener for 'M' key to toggle audio
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyM') {
                toggleAudio();
            }
        });

        async function startGame() {
            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            menu.style.display = 'none';
            gameState.gameStarted = true;
            
            // Get the AI enemies toggle state
            aiEnemiesEnabled = document.getElementById('ai-enemies-toggle').checked;
            
            // Reset game state and initialize game elements
            await resetGame();
            
            // Start playing audio since default is unmuted
            if (audioPlaying) {
                playGameplayAudio();
            }
            
            // Ensure game loop is running
            if (!gameLoopStarted) {
                gameLoopStarted = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function toggleAudio() {
            audioPlaying = !audioPlaying;
            
            if (!audioPlaying) {
                stopAllAudio();
                toggleAudioButton.textContent = 'üîá';
            } else {
                if (gameState.isVictory) {
                    playVictoryAudio();
                } else if (gameState.gameStarted && !gameState.isGameOver) {
                    playGameplayAudio();
                }
                toggleAudioButton.textContent = 'üîä';
            }
        }

        function playGameplayAudio() {
            if (!audioContext || !gameplayBuffer) return;
            
            stopAllAudio();
            
            gameplaySource = audioContext.createBufferSource();
            gameplaySource.buffer = gameplayBuffer;
            gameplaySource.loop = true;
            gameplaySource.connect(audioContext.destination);
            
            try {
                gameplaySource.start(0);
            } catch (error) {
                console.error("Error starting gameplay audio:", error);
            }
        }

        function playVictoryAudio() {
            if (!audioContext || !victoryBuffer) return;
            
            stopAllAudio();
            
            victorySource = audioContext.createBufferSource();
            victorySource.buffer = victoryBuffer;
            victorySource.connect(audioContext.destination);
            
            try {
                victorySource.start(0);
            } catch (error) {
                console.error("Error starting victory audio:", error);
            }
        }

        function stopAllAudio() {
            if (gameplaySource) {
                try {
                    gameplaySource.stop();
                } catch (e) {}
                gameplaySource = null;
            }
            
            if (victorySource) {
                try {
                    victorySource.stop();
                } catch (e) {}
                victorySource = null;
            }
        }

        async function resetGame() {
            gameState = {
                hearts: INITIAL_HEARTS,
                level: 1,
                score: 0,
                isGameOver: false,
                isVictory: false,
                ballSpeed: INITIAL_BALL_SPEED,
                ballCanKill: false,
                gameStarted: true
            };
            
            ball = resetBall();
            resetPaddlePositions();
            gnomes = generateGnomes();
            replayButton.style.display = 'none';
            
            // Reset portal
            portalActive = false;
            portalSize = 0;
            document.getElementById('portal').classList.remove('active');
            document.getElementById('portal-button').disabled = false;
            document.getElementById('portal-button').style.opacity = 1;
            
            // Generate a new AI enemy if enabled
            if (aiEnemiesEnabled) {
                aiEnemy = await generateAIEnemy();
                aiEnemyEffect = null;
            } else {
                aiEnemy = null;
            }
            
            // Restart gameplay audio if it was previously playing
            if (audioPlaying) {
                playGameplayAudio();
            }
        }

        function resetBall() {
            return {
                x: canvas.width / 2,
                y: canvas.height / 2,
                dx: Math.random() > 0.5 ? gameState.ballSpeed : -gameState.ballSpeed,
                dy: Math.random() > 0.5 ? gameState.ballSpeed : -gameState.ballSpeed
            };
        }

        function generateGnomes() {
            const count = Math.min(32, Math.pow(2, gameState.level - 1));
            const gnomes = [];
            const safeZone = 150;
            let maxAttempts = 100;

            for (let i = 0; i < count; i++) {
                let x, y;
                let attempts = 0;
                let validPosition = false;
                
                while (!validPosition && attempts < maxAttempts) {
                    x = safeZone + Math.random() * (canvas.width - 2 * safeZone);
                    y = safeZone + Math.random() * (canvas.height - 2 * safeZone);
                    validPosition = !isPositionOccupied(x, y, gnomes);
                    attempts++;
                }
                
                if (!validPosition) {
                    x = canvas.width / 2 + (Math.random() - 0.5) * 100;
                    y = canvas.height / 2 + (Math.random() - 0.5) * 100;
                }

                gnomes.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * GNOME_SPEED * (1 + gameState.level * 0.1),
                    dy: (Math.random() - 0.5) * GNOME_SPEED * (1 + gameState.level * 0.1)
                });
            }
            
            return gnomes;
        }

        function isPositionOccupied(x, y, gnomes) {
            const minDistance = GNOME_IMAGE_SIZE;
            
            for (let gnome of gnomes) {
                const distance = Math.sqrt(Math.pow(x - gnome.x, 2) + Math.pow(y - gnome.y, 2));
                if (distance < minDistance) return true;
            }
            return false;
        }

        async function nextLevel() {
            gameState.level++;
            gameState.hearts = INITIAL_HEARTS;
            gameState.ballSpeed = INITIAL_BALL_SPEED * (1 + (gameState.level - 1) * 0.05);
            ball = resetBall();
            resetPaddlePositions();
            gnomes = generateGnomes();
            gameState.ballCanKill = false;
            
            // Generate a new AI enemy if enabled
            if (aiEnemiesEnabled) {
                aiEnemy = await generateAIEnemy();
                aiEnemyEffect = null;
            } else {
                aiEnemy = null;
            }
        }

        function resetPaddlePositions() {
            paddles.left.y = canvas.height / 2 - PADDLE_WIDTH / 2;
            paddles.right.y = canvas.height / 2 - PADDLE_WIDTH / 2;
            paddles.top.x = canvas.width / 2 - PADDLE_WIDTH / 2;
            paddles.bottom.x = canvas.width / 2 - PADDLE_WIDTH / 2;
            
            // Reset active status
            paddles.left.active = false;
            paddles.right.active = false;
            paddles.top.active = false;
            paddles.bottom.active = false;
        }

        // Keyboard controls
        let keys = {
            ArrowLeft: false,
            ArrowRight: false,
            ArrowUp: false,
            ArrowDown: false
        };
        
        let activePaddle = null;

        document.addEventListener('keydown', (e) => {
            // WASD keys select the active paddle
            if (e.code === 'KeyW') activePaddle = 'top';
            else if (e.code === 'KeyA') activePaddle = 'left';
            else if (e.code === 'KeyS') activePaddle = 'bottom';
            else if (e.code === 'KeyD') activePaddle = 'right';
            
            // Set arrow key state
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            // Update arrow key state
            if (keys.hasOwnProperty(e.code)) {
                keys[e.code] = false;
            }
        });

        async function generateAIEnemy() {
            if (!aiEnemiesEnabled) return null;
            
            try {
                const prompt = `Generate a JSON object for a game enemy with these properties:
                1. A random color (in hex format)
                2. A special effect (one of: "speed_up", "slow_down", "enlarge_ball", "shrink_ball", "reverse_controls", "extra_life", "multi_ball")
                3. A name for this enemy
                4. A description of what it does
                Format the response as a valid JSON object with keys: color, effect, name, description`;
                
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: "llama3-70b-8192",
                        messages: [
                            {
                                role: "user",
                                content: prompt
                            }
                        ],
                        temperature: 0.9,
                        max_tokens: 500
                    })
                });
                
                if (!response.ok) {
                    const error = await response.text();
                    console.error("API Error:", error);
                    return generateFallbackEnemy();
                }
                
                const data = await response.json();
                const enemyData = JSON.parse(data.choices[0].message.content);
                
                console.log("AI Enemy Generated:", enemyData);
                
                // Generate the enemy with position similar to gnomes
                const safeZone = 150;
                const x = safeZone + Math.random() * (canvas.width - 2 * safeZone);
                const y = safeZone + Math.random() * (canvas.height - 2 * safeZone);
                
                return {
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * GNOME_SPEED * 1.5,
                    dy: (Math.random() - 0.5) * GNOME_SPEED * 1.5,
                    color: enemyData.color,
                    effect: enemyData.effect,
                    name: enemyData.name,
                    description: enemyData.description,
                    size: GNOME_SIZE * 1.5
                };
            } catch (error) {
                console.error("Error generating AI enemy:", error);
                return generateFallbackEnemy();
            }
        }

        function generateFallbackEnemy() {
            const effects = ["speed_up", "slow_down", "enlarge_ball", "shrink_ball", "reverse_controls", "extra_life", "multi_ball"];
            const colors = ["#FF5733", "#33FF57", "#3357FF", "#F033FF", "#FF33F0", "#33FFF0", "#F0FF33"];
            
            const randomEffect = effects[Math.floor(Math.random() * effects.length)];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            const safeZone = 150;
            const x = safeZone + Math.random() * (canvas.width - 2 * safeZone);
            const y = safeZone + Math.random() * (canvas.height - 2 * safeZone);
            
            return {
                x: x,
                y: y,
                dx: (Math.random() - 0.5) * GNOME_SPEED * 1.5,
                dy: (Math.random() - 0.5) * GNOME_SPEED * 1.5,
                color: randomColor,
                effect: randomEffect,
                name: "Enemy",
                description: "A randomly generated enemy due to API limitation",
                size: GNOME_SIZE * 1.5
            };
        }

        function applyAIEnemyEffect() {
            if (!aiEnemy || !aiEnemyEffect) return;
            
            const effect = aiEnemy.effect;
            
            // Apply the effect
            switch(effect) {
                case "speed_up":
                    ball.dx *= 1.5;
                    ball.dy *= 1.5;
                    break;
                case "slow_down":
                    ball.dx *= 0.7;
                    ball.dy *= 0.7;
                    break;
                case "enlarge_ball":
                    // We'll handle this in the draw function
                    break;
                case "shrink_ball":
                    // We'll handle this in the draw function
                    break;
                case "reverse_controls":
                    // Reverse the arrow key states
                    let temp = keys.ArrowLeft;
                    keys.ArrowLeft = keys.ArrowRight;
                    keys.ArrowRight = temp;
                    
                    temp = keys.ArrowUp;
                    keys.ArrowUp = keys.ArrowDown;
                    keys.ArrowDown = temp;
                    break;
                case "extra_life":
                    gameState.hearts += 1;
                    break;
                case "multi_ball":
                    // For simplicity, we'll just make the ball move faster in random directions
                    ball.dx = (Math.random() > 0.5 ? 1 : -1) * gameState.ballSpeed * 2;
                    ball.dy = (Math.random() > 0.5 ? 1 : -1) * gameState.ballSpeed * 2;
                    break;
            }
            
            // Set the effect duration with a timeout
            setTimeout(() => {
                aiEnemyEffect = null;
            }, 5000);
        }

        function activatePortal() {
            if (!portalActive && !gameState.isGameOver && !gameState.isVictory) {
                portalActive = true;
                document.getElementById('portal').classList.add('active');
                document.getElementById('portal-button').disabled = true;
                document.getElementById('portal-button').style.opacity = 0.5;
            }
        }

        function updatePortal() {
            if (!portalActive) return;
            
            const portal = document.getElementById('portal');
            portalSize += PORTAL_GROWTH_RATE;
            
            if (portalSize > MAX_PORTAL_SIZE) {
                portalSize = MAX_PORTAL_SIZE;
            }
            
            portal.style.width = `${portalSize}px`;
            portal.style.height = `${portalSize}px`;
            
            // Calculate distance from ball to portal center
            const portalCenterX = canvas.width / 2;
            const portalCenterY = canvas.height / 2;
            const dx = portalCenterX - ball.x;
            const dy = portalCenterY - ball.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Apply suction force if ball is close enough
            if (distance < MAX_PORTAL_SIZE * 2) {
                // Calculate suction magnitude (stronger when closer)
                const suctionMagnitude = SUCTION_FORCE * (1 - Math.min(distance / (MAX_PORTAL_SIZE * 2), 1));
                
                // Apply suction force vector to ball velocity
                ball.dx += (dx / distance) * suctionMagnitude;
                ball.dy += (dy / distance) * suctionMagnitude;
                
                // If ball is sucked into the portal
                if (distance < portalSize / 2) {
                    // Stop the game loop and audio before redirecting
                    gameState.isGameOver = true;
                    if (audioPlaying) {
                        stopAllAudio();
                    }
                    
                    // Add a visual effect before redirecting
                    portal.style.boxShadow = '0 0 50px #0f0';
                    portal.style.opacity = '1';
                    
                    // Redirect after a short delay for visual effect
                    setTimeout(() => {
                        window.location.href = "http://portal.pieter.com/";
                    }, 500);
                }
            }
        }

        function updatePaddles() {
            // Reset all paddles to inactive
            Object.keys(paddles).forEach(key => {
                paddles[key].active = (key === activePaddle);
            });
            
            // Handle paddle movement based on active paddle
            if (activePaddle === 'top') {
                if (keys.ArrowLeft) {
                    paddles.top.x = Math.max(0, paddles.top.x - PADDLE_SPEED);
                }
                if (keys.ArrowRight) {
                    paddles.top.x = Math.min(canvas.width - paddles.top.width, paddles.top.x + PADDLE_SPEED);
                }
            } else if (activePaddle === 'bottom') {
                if (keys.ArrowLeft) {
                    paddles.bottom.x = Math.max(0, paddles.bottom.x - PADDLE_SPEED);
                }
                if (keys.ArrowRight) {
                    paddles.bottom.x = Math.min(canvas.width - paddles.bottom.width, paddles.bottom.x + PADDLE_SPEED);
                }
            } else if (activePaddle === 'left') {
                if (keys.ArrowUp) {
                    paddles.left.y = Math.max(0, paddles.left.y - PADDLE_SPEED);
                }
                if (keys.ArrowDown) {
                    paddles.left.y = Math.min(canvas.height - paddles.left.height, paddles.left.y + PADDLE_SPEED);
                }
            } else if (activePaddle === 'right') {
                if (keys.ArrowUp) {
                    paddles.right.y = Math.max(0, paddles.right.y - PADDLE_SPEED);
                }
                if (keys.ArrowDown) {
                    paddles.right.y = Math.min(canvas.height - paddles.right.height, paddles.right.y + PADDLE_SPEED);
                }
            }
        }

        function updateBall() {
            // Update ball position
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Check for AI enemy collision
            if (aiEnemy && gameState.ballCanKill) {
                const dx = ball.x - aiEnemy.x;
                const dy = ball.y - aiEnemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < aiEnemy.size + BALL_SIZE) {
                    aiEnemyEffect = aiEnemy.effect;
                    applyAIEnemyEffect();
                    gameState.score += 50 * gameState.level;
                    aiEnemy = null;
                }
            }

            // Check for paddle collisions first
            // Left paddle
            if (ball.x <= paddles.left.x + paddles.left.width &&
                ball.y >= paddles.left.y &&
                ball.y <= paddles.left.y + paddles.left.height &&
                ball.dx < 0) {
                ball.dx = -ball.dx;
                gameState.ballCanKill = true;
            }
            // Right paddle
            else if (ball.x >= paddles.right.x - BALL_SIZE &&
                ball.y >= paddles.right.y &&
                ball.y <= paddles.right.y + paddles.right.height &&
                ball.dx > 0) {
                ball.dx = -ball.dx;
                gameState.ballCanKill = true;
            }
            // Top paddle
            else if (ball.y <= paddles.top.y + paddles.top.height &&
                ball.x >= paddles.top.x &&
                ball.x <= paddles.top.x + paddles.top.width &&
                ball.dy < 0) {
                ball.dy = -ball.dy;
                gameState.ballCanKill = true;
            }
            // Bottom paddle
            else if (ball.y >= paddles.bottom.y - BALL_SIZE &&
                ball.x >= paddles.bottom.x &&
                ball.x <= paddles.bottom.x + paddles.bottom.width &&
                ball.dy > 0) {
                ball.dy = -ball.dy;
                gameState.ballCanKill = true;
            }
            // Check for wall collisions (out of bounds)
            else if (ball.x < 0 || ball.x > canvas.width || ball.y < 0 || ball.y > canvas.height) {
                gameState.hearts--;
                gameState.ballCanKill = false;
                
                if (gameState.hearts <= 0) {
                    gameState.isGameOver = true;
                    replayButton.style.display = 'block';
                    
                    // Stop audio when game is over but keep audio toggle state
                    if (audioPlaying) {
                        stopAllAudio();
                    }
                } else {
                    // Reset ball position when it goes out of bounds
                    ball = resetBall();
                }
            }
        }

        function updateGnomes() {
            // Update AI enemy if exists
            if (aiEnemy) {
                aiEnemy.x += aiEnemy.dx;
                aiEnemy.y += aiEnemy.dy;
                
                const paddleMargin = 100;
                if (aiEnemy.x < paddleMargin || aiEnemy.x > canvas.width - paddleMargin) {
                    aiEnemy.dx = -aiEnemy.dx;
                }
                if (aiEnemy.y < paddleMargin || aiEnemy.y > canvas.height - paddleMargin) {
                    aiEnemy.dy = -aiEnemy.dy;
                }
            }

            // Update gnomes
            for (let i = gnomes.length - 1; i >= 0; i--) {
                const gnome = gnomes[i];

                gnome.x += gnome.dx;
                gnome.y += gnome.dy;

                const paddleMargin = 100;
                if (gnome.x < paddleMargin || gnome.x > canvas.width - paddleMargin) {
                    gnome.dx = -gnome.dx;
                }
                if (gnome.y < paddleMargin || gnome.y > canvas.height - paddleMargin) {
                    gnome.dy = -gnome.dy;
                }

                if (gameState.ballCanKill) {
                    const dx = ball.x - gnome.x;
                    const dy = ball.y - gnome.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < GNOME_SIZE + BALL_SIZE) {
                        gnomes.splice(i, 1);
                        gameState.score += 10 * gameState.level;
                    }
                }
            }

            if (gnomes.length === 0) {
                if (gameState.level >= MAX_LEVEL) {
                    gameState.isVictory = true;
                    replayButton.style.display = 'block';
                    
                    // Stop gameplay audio and play victory audio
                    if (audioPlaying) {
                        playVictoryAudio();
                    }
                } else {
                    nextLevel();
                }
            }
        }

        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Draw vertical grid lines
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal grid lines
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw paddles
            ctx.fillStyle = PADDLE_COLOR;
            Object.values(paddles).forEach(paddle => {
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
                
                // Highlight active paddle with a glow effect
                if (paddle.active) {
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(paddle.x - 2, paddle.y - 2, paddle.width + 4, paddle.height + 4);
                    
                    // Add glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = "#FFF";
                    ctx.strokeRect(paddle.x - 2, paddle.y - 2, paddle.width + 4, paddle.height + 4);
                    ctx.shadowBlur = 0;
                }
            });

            // Draw ball with glow effect (adjust size if enemy effect is active)
            let ballSize = BALL_SIZE;
            if (aiEnemyEffect) {
                if (aiEnemyEffect === "enlarge_ball") {
                    ballSize = BALL_SIZE * 2;
                } else if (aiEnemyEffect === "shrink_ball") {
                    ballSize = BALL_SIZE * 0.5;
                }
            }
            
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ballSize, 0, Math.PI * 2);
            ctx.fillStyle = BALL_COLOR;
            
            // Add glow effect if ball can kill
            if (gameState.ballCanKill) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = BALL_COLOR;
            }
            
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0;

            // Draw AI enemy if exists
            if (aiEnemy) {
                ctx.beginPath();
                ctx.arc(aiEnemy.x, aiEnemy.y, aiEnemy.size, 0, Math.PI * 2);
                ctx.fillStyle = aiEnemy.color;
                
                // Add glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = aiEnemy.color;
                
                ctx.fill();
                ctx.closePath();
                ctx.shadowBlur = 0;
                
                // Draw enemy name above it
                ctx.font = '14px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(aiEnemy.name, aiEnemy.x, aiEnemy.y - aiEnemy.size - 10);
            }

            // Draw gnomes using the image
            gnomes.forEach(gnome => {
                try {
                    const halfSize = GNOME_IMAGE_SIZE / 2;
                    ctx.drawImage(
                        gnomeImage, 
                        gnome.x - halfSize, 
                        gnome.y - halfSize, 
                        GNOME_IMAGE_SIZE, 
                        GNOME_IMAGE_SIZE
                    );
                } catch (err) {
                    // Fallback to a simple circle if image fails
                    ctx.beginPath();
                    ctx.arc(gnome.x, gnome.y, GNOME_SIZE, 0, Math.PI * 2);
                    ctx.fillStyle = "red";
                    ctx.fill();
                    ctx.closePath();
                }
            });

            // Show active effect if any
            if (aiEnemyEffect) {
                ctx.font = '18px Arial';
                ctx.fillStyle = 'yellow';
                ctx.textAlign = 'left';
                ctx.fillText(`Active Effect: ${aiEnemyEffect.replace(/_/g, ' ')}`, 10, 30);
            }

            // Update game info
            let enemyInfo = aiEnemy ? ` | AI Enemy: ${aiEnemy.name}` : '';
            gameInfo.textContent = `Hearts: ${gameState.hearts} | Level: ${gameState.level}/${MAX_LEVEL} | Score: ${gameState.score} | Gnomes: ${gnomes.length}${enemyInfo}`;

            // Draw game over / victory overlay
            if (gameState.isGameOver || gameState.isVictory) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Set text style with shadow for better visibility
                ctx.fillStyle = gameState.isVictory ? '#4CFF00' : '#FF0000';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = gameState.isVictory ? '#4CFF00' : '#FF0000';
                
                ctx.fillText(
                    gameState.isVictory ? 'Victory!' : 'Game Over!',
                    canvas.width / 2,
                    canvas.height / 2
                );
                
                // Add final score
                ctx.font = '24px Arial';
                ctx.fillText(
                    `Final Score: ${gameState.score}`,
                    canvas.width / 2,
                    canvas.height / 2 + 50
                );
                
                ctx.shadowBlur = 0;
            }
        }

        function gameLoop() {
            if (gameState.gameStarted && !gameState.isGameOver && !gameState.isVictory) {
                updatePaddles();
                updateBall();
                updateGnomes();
                
                // Update portal if active
                if (portalActive) {
                    updatePortal();
                }
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        async function loadAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const gameplayResponse = await fetch("https://dl.dropboxusercontent.com/scl/fi/v34mo7e0s726ld8vsd2es/SNEW_Battle.wav?rlkey=cns3v28ox417ijl6svwf54ff0&st=haqhz9ga&raw=1");
                const gameplayArrayBuffer = await gameplayResponse.arrayBuffer();
                gameplayBuffer = await audioContext.decodeAudioData(gameplayArrayBuffer);
                
                const victoryResponse = await fetch("https://dl.dropboxusercontent.com/scl/fi/5prg2gxmiz1i7dvlz8qdd/SNEW_Victory.wav?rlkey=eat0zwm67qhn6m0rxk1oek3gf&st=afr1yabw&raw=1");
                const victoryArrayBuffer = await victoryResponse.arrayBuffer();
                victoryBuffer = await audioContext.decodeAudioData(victoryArrayBuffer);
                
                console.log("Audio loaded successfully");
            } catch (error) {
                console.error("Error loading audio:", error);
            }
        }

        // Initialize game
        function init() {
            // Hide replay button initially
            replayButton.style.display = 'none';
            
            // Initialize game info
            gameInfo.textContent = `Hearts: ${gameState.hearts} | Level: ${gameState.level}/${MAX_LEVEL} | Score: ${gameState.score} | Gnomes: 0`;
            
            // Load audio
            loadAudio();
            
            // Draw initial screen but don't start game loop until user clicks Start
            draw();
        }

        // Initial setup
        init();
    </script>
</body>
</html>
